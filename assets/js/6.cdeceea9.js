(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{172:function(e,a,t){"use strict";t.r(a);var n=t(0),r=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"new-date-atime-new-date-btime-引发的思考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#new-date-atime-new-date-btime-引发的思考","aria-hidden":"true"}},[e._v("#")]),e._v(" new Date(aTIme) - new Date(bTime)引发的思考")]),e._v(" "),t("h2",{attrs:{id:"事情发生场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事情发生场景","aria-hidden":"true"}},[e._v("#")]),e._v(" 事情发生场景")]),e._v(" "),t("p",[e._v("一刚入行的朋友，问我一些今天遇到的问题，然后解答完毕，并优化了该段代码")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 优化前\narr.sort((a, b) => {\n    let aTime = new Date(a.time).getTime()\n    let bTime = new Date(b.time).getTime()\n    return aTime - bTIme\n})\n\n// 优化后\narr.sort((a, b) => new Date(a.time) - new Date(b.time))\n")])])]),t("p",[e._v("然后就在想，不加getTime也能运行是浏览器自己转的吗，会有兼容问题吗，于是上了mdn上一查：Date.prototype.getTime与valueof一致，所以能确认这个不会有浏览器的问题")]),e._v(" "),t("h2",{attrs:{id:"什么是valueof"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是valueof","aria-hidden":"true"}},[e._v("#")]),e._v(" 什么是valueof")]),e._v(" "),t("p",[e._v("以下是mdn的内容：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("JavaScript调用valueOf方法将对象转换为原始值。你很少需要自己调用valueOf方法；当遇到要预期的原始值的对象时，JavaScript会自动调用它。\n\n默认情况下，valueOf方法由Object后面的每个对象继承。 每个内置的核心对象都会覆盖此方法以返回适当的值。如果对象没有原始值，则valueOf将返回对象本身。\n\nJavaScript的许多内置对象都重写了该函数，以实现更适合自身的功能需要。因此，不同类型对象的valueOf()方法的返回值和返回值类型均可能不同。\n不同类型对象的valueOf()方法的返回值\n对象\t    返回值\nArray\t    返回数组对象本身。\nBoolean\t    布尔值。\nDate\t    存储的时间是从 1970 年 1 月 1 日午夜开始计的毫秒数 UTC。\nFunction\t函数本身。\nNumber\t    数字值。\nObject\t    对象本身。这是默认情况。\nString\t    字符串值。\n \tMath 和 Error 对象没有 valueOf 方法。\n你可以在自己的代码中使用valueOf将内置对象转换为原始值。 创建自定义对象时，可以覆盖Object.prototype.valueOf()来调用自定义方法，而不是默认Object方法。\n")])])]),t("p",[e._v("简而言之，valueOf我们很少会主动调用它，一般是js里自动调用，在需要用到对象原始值时（一般在做运算时）。")]),e._v(" "),t("h2",{attrs:{id:"重写valueof"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#重写valueof","aria-hidden":"true"}},[e._v("#")]),e._v(" 重写valueof")]),e._v(" "),t("p",[e._v("写了个例子，简单阐述了valueOf是否自动调用")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var a = {}, b = 1\nconsole.log(a + b) // [object Object]1\na.valueOf = function(){return 1}\nconsole.log(a + b)  // 2\nb.valueOf = function () {return 2}\nconsole.log(a + b)  // 2 数字在进行运算时不会执行valeof\n\n")])])]),t("p",[e._v("可以看到最后打印出的是2，所以a+1时自动调用了a的valueOf")]),e._v(" "),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结","aria-hidden":"true"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),t("p",[e._v("valueOf一般是js内部自己调用的，一般不需要js显示调用，直到它的用处和原理，可以更好的简化代码～")])])}],!1,null,null,null);a.default=r.exports}}]);